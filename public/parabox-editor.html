<html>
  <head>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap"
      rel="stylesheet"
    />
  </head>
  <body>
    <style>
      body {
        margin: 0;
      }
      * {
        box-sizing: border-box;
      }
      table {
        /* cell-spacing: 0; */
        border-collapse: collapse;
        border-spacing: 0;
        margin: 0;
        padding: 0;
      }
      td {
        margin: 0;
        padding: 0;
      }
      svg.cartesian {
        display: flex;
      }

      /* Flip the vertical axis in <g> to emulate cartesian. */
      svg.cartesian > g {
        transform: scaleY(-1);
      }

      /* Re-flip all <text> element descendants to their original side up. */
      svg.cartesian > g text {
        /* TODO fix all this flip */
        /* transform: scaleY(-1); */
      }
    </style>
    <script src="https://unpkg.com/vue@next"></script>
    <script src="https://unpkg.com/vue-color-input@latest"></script>
    <script src="https://unpkg.com/tinycolor2@1.4.2/dist/tinycolor-min.js"></script>
    <script>
      Array.prototype.remove = function (el) {
        const index = this.indexOf(el);
        if (index >= 0) {
          this.splice(index, 1);
        }
      };
      Array.prototype.count = function (predicate = () => true) {
        return this.reduce((result, item, index) => {
          if (predicate(item, index, this)) {
            return result + 1;
          } else {
            return result;
          }
        }, 0);
      };
      Object.defineProperties(Array.prototype, {
        last: {
          get() {
            return this[this.length - 1];
          },
          set(newValue) {
            if (this.length <= 0)
              throw new Error("cannot overwrite last value of empty array");
            this[this.length - 1] = newValue;
          },
        },
      });
      {
        (() => {
          function addCurrentAccesor(proto) {
            const descriptor = Object.getOwnPropertyDescriptor(proto, "value");
            Object.defineProperties(proto, {
              current: {
                configurable: true,
                enumerable: false,
                get: descriptor.get,
                set: descriptor.set,
              },
            });
          }
          addCurrentAccesor(Vue.ref().__proto__);
          addCurrentAccesor(Vue.computed(() => {}).__proto__);
          addCurrentAccesor(Vue.toRefs(Vue.reactive({ x: 0 })).x.__proto__);
        })();
      }

      function pipe(init, ...fs) {
        return fs.reduce((curr, f) => f(curr), init);
      }
      pipe.it = Symbol("pipe.it");
      pipe.bound = (f, ...args) => {
        return (it) => {
          const realArgs = args.map((x) => (x === pipe.it ? it : x));
          return f(...realArgs);
        };
      };
      const pipeWrap =
        (f) =>
        (...args) =>
        (x) =>
          f(x, ...args);
      pipe.map = pipeWrap(map);

      function* range(...args) {
        let lo = 0,
          hi,
          step = 1;
        if (args.length === 1) {
          [hi] = args;
        } else {
          [lo, hi, step = step] = args;
        }
        let curr = lo;
        while ((hi - curr) / step > 0) {
          yield curr;
          curr += step;
        }
      }
      function* map(iterable, mapper) {
        let i = 0;
        for (const x of iterable) {
          yield mapper(x, i);
          i++;
        }
      }
      function collect(iterable) {
        return Array.from(iterable);
      }
      function forEach(iterable, action) {
        for (const x of iterable) {
          action(x);
        }
      }
      function* filter(iterable, filterer) {
        for (const x of iterable) {
          if (filterer(x)) {
            yield x;
          }
        }
      }
      function* pairs(iterable) {
        let prev = null;
        let first = true;
        for (const x of iterable) {
          if (!first) {
            yield [prev, x];
          } else {
            first = false;
          }
          prev = x;
        }
      }
      function* enumerate(iterable) {
        let i = 0;
        for (const x of iterable) {
          yield [x, i];
          i++;
        }
      }
      function* groups(iterable, n = 2, every = 1) {
        const prev = [];
        for (const [x, i] of enumerate(iterable)) {
          prev.push(x);
          if (prev.length > n) prev.shift();
          if (i >= n - 1 && (i - n + 1) % every == 0) {
            yield prev.slice();
          }
        }
      }
      function* reverse(array) {
        for (const i of range(array.length, 0, -1)) {
          yield array[i - 1];
        }
      }
      function sum(iterable) {
        let s = 0;
        for (const x of iterable) {
          s += x;
        }
        return s;
      }
      function* generateAllPermutations(arr) {
        if (arr.length == 0) {
          yield [];
          return;
        }

        for (const i of range(0, arr.length)) {
          const newArray = arr.filter((x, j) => j != i);
          for (const sub of generateAllPermutations(newArray)) {
            yield [arr[i], ...sub];
          }
        }
      }
      function maxOf(arr, acc) {
        let bestScore = null;
        let best = undefined;
        for (const x of arr) {
          const score = acc(x);
          if (bestScore === null || score > bestScore) {
            best = x;
            bestScore = score;
          }
        }
        return best;
      }
      function randomInt(lo, hi, step = 1) {
        return Math.floor((Math.random() * (hi - lo)) / step) * step + lo;
      }
      function randomChoice(items) {
        const index = randomInt(0, items.length);
        return items[index];
      }
      function fromPolar(angle, r = 1) {
        return { x: Math.cos(angle) * r, y: Math.sin(angle) * r };
      }
      function useEventHandler(target, eventType, handler) {
        Vue.onMounted(() => {
          target.addEventListener(eventType, handler);
        });
        Vue.onBeforeUnmount(() => {
          target.removeEventListener(eventType, handler);
        });
      }
      function useComputedStorage(
        key,
        initialValue,
        storage = localStorage,
        transform = JSON
      ) {
        let value = storage.getItem(key);
        if (value == null) {
          value = initialValue;
        } else {
          value = transform.parse(value);
        }
        const _valueRef = Vue.ref(value);
        const valueRef = Vue.computed({
          get: () => _valueRef.value,
          set: (newValue) => {
            _valueRef.value = newValue;
            storage.setItem(key, transform.stringify(_valueRef.value));
          },
        });
        useEventHandler(window, "storage", (event) => {
          if (event.storageArea === storage && event.key === key) {
            valueRef.value = transform.parse(event.newValue);
          }
        });
        return valueRef;
      }
      function useTimeout(effect, delay, source) {
        let timeoutId = -1;
        const staleRef = Vue.ref(false);
        Vue.watch(source, () => {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => {
            effect();
            timeoutId = -1;
            staleRef.value = false;
          }, delay);
          staleRef.value = true;
        });
        return { stale: staleRef };
      }
      function createContext(defaultValue) {
        const hasDefault = arguments.length >= 1;
        const symbol = Symbol();
        return {
          provide(value) {
            Vue.provide(symbol, value);
          },
          inject(myDefault) {
            const passedDefault = arguments.length >= 1;
            return Vue.inject(
              symbol,
              passedDefault
                ? myDefault
                : hasDefault
                ? defaultValue
                : Vue.computed(() => {
                    throw new Error("no default");
                  })
            );
          },
        };
      }
      function listed(
        array,
        separator = ", ",
        and = " and ",
        nothing = "",
        oxford = true
      ) {
        if (array.length === 0) return `${nothing}`;
        if (array.length === 1) return `${array[0]}`;
        if (array.length === 2) return `${array[0]}${and}${array[1]}`;
        return array
          .map((x, i) => {
            return `${
              i > 0 && (i < array.length - 1 || oxford) ? separator : ""
            }${i === array.length - 1 ? and : ""}${x}`;
          })
          .join("");
      }
    </script>
    <script>
      var app = Vue.createApp({});
      var roomContext = createContext();
      var levelContext = createContext();
      var stateContext = createContext();
    </script>

    <script>
      app.config.globalProperties.$filters = {
        listed,
        json: (x) => JSON.stringify(x),
      };

      function not(ref) {
        return Vue.computed(() => !ref.current);
      }

      function usePeriodic(effect, _getPeriod, enabledRef, debug) {
        let timeoutId = null;

        const getPeriod = () => {
          const value = _getPeriod();
          if (debug) console.log(value);
          return value;
        };

        function update() {
          if (enabledRef.current) {
            timeoutId = setTimeout(() => {
              effect();
              update();
            }, getPeriod());
          } else {
            timeoutId = null;
          }
        }

        update();

        Vue.watch(enabledRef, (isEnabled, wasEnabled) => {
          if (isEnabled && !wasEnabled && timeoutId === null) {
            update(); // need to restart was disabled
          }
          if (wasEnabled && !isEnabled && timeoutId !== null) {
            clearTimeout(timeoutId);
            timeoutId = null;
          }
        });

        Vue.onUnmounted(() => {
          clearTimeout(timeoutId);
        });
      }

      class DefaultMap extends Map {
        constructor(defaultComputer, ...args) {
          super(...args);
          this.defaultComputer = defaultComputer;
        }
        get(key) {
          if (!this.has(key)) {
            this.set(key, this.defaultComputer(key));
          }
          return super.get(key);
        }
      }

      class ListMap extends DefaultMap {
        constructor(...args) {
          super(() => [], ...args);
        }
      }

      const { useKeybind } = (function () {
        const registrations = new ListMap();
        function handler(event) {
          registrations.get(event.code).forEach((h) => {
            h();
          });
        }
        document.addEventListener("keydown", handler);
        function useKeybind(keycode, handler) {
          function uniqueHandler() {
            handler();
          }
          registrations.get(keycode).push(uniqueHandler);
          Vue.onUnmounted(() => {
            registrations.get(keycode).remove(uniqueHandler);
          });
        }
        return { useKeybind };
      })();

      const { nowRef } = (function () {
        const nowRef = Vue.ref(performance.now());

        function update() {
          setTimeout(() => {
            nowRef.current = performance.now();
            update();
          }, 50);
        }

        update();

        return { nowRef };
      })();
    </script>

    <style>
      html {
        font-family: "Roboto", sans-serif;
      }
      html,
      body {
        min-height: 100vh;
      }
      body {
        background: #eee;
      }
      .hide {
        display: none;
      }
      .container {
        max-width: 720px;
        margin-left: auto;
        margin-right: auto;
        min-height: 100%;
      }
      .full-column {
        display: flex;
        flex-flow: column nowrap;
        min-height: 100%;
      }
      .mt {
        padding-top: 20px;
      }
      .mb {
        padding-bottom: 20px;
      }

      .position-root {
        position: relative;
      }
      .position-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }

      .button {
        background: #dde;
        border: 1px outset gray;
        border-radius: 5px;
        padding: 4px 10px;
        font-family: inherit;
        font-size: 1rem;
      }

      .button:hover {
        background: #aab;
      }

      .button:active {
        background: #887;
      }
    </style>

    <style>
      .cell {
        width: 100%;
        height: 100%;
        position: relative;
      }
      .cell > * {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
      }
      .cell--wall {
        background-color: lightgray;
        border: 10px outset gray;
        border-radius: 10px;
      }
      .cell--wall--right {
        border-right-width: 0;
      }
      .cell--wall--left {
        border-left-width: 0;
      }
      .cell--wall--top {
        border-top-width: 0;
      }
      .cell--wall--bottom {
        border-bottom-width: 0;
      }
      .cell--wall--right,
      .cell--wall--top {
        border-top-right-radius: 0;
      }
      .cell--wall--left,
      .cell--wall--top {
        border-top-left-radius: 0;
      }
      .cell--wall--left,
      .cell--wall--bottom {
        border-bottom-left-radius: 0;
      }
      .cell--wall--right,
      .cell--wall--bottom {
        border-bottom-right-radius: 0;
      }
      .cell--box {
        border: 2px solid black;
        background-color: yellow;
      }
      .cell--player {
        background-color: red;
      }
      .cell--floor {
        background-color: darkgray;
        border: 1px solid gray;
      }
      .cell--room-placeholder {
        background-color: blue;
      }
      .cell__button-overlay {
        left: 5px;
        right: 5px;
        top: 5px;
        bottom: 5px;
        border: 5px solid #eee;
      }
      .player-eyes {
        transform: rotate(90deg);
        text-align: center;
        font-size: 50px;
      }
    </style>
    <script type="text/html" id="cell-view">
      <div class="cell">
        <div class="cell--floor"></div>
        <div v-if="isWall" :class="wallClasses"></div>
        <div v-if="isBox" class="cell--box"></div>
        <div v-if="isPlayer" class="cell--player"></div>
        <template v-if="isRoom">
          <div v-if="depth > 0">
            <room-view :room-id="innerRoom.id" :depth="depth - 1"></room-view>
          </div>
          <div v-else class="cell--room-placeholder"></div>
        </template>
        <div
          v-if="isButton || isPlayerButton"
          class="cell__button-overlay"
        ></div>
        <div v-if="isPlayer || isPlayerButton" class="player-eyes">:</div>
      </div>
    </script>
    <script>
      app.component("cell-view", {
        template: "#cell-view",
        props: ["x", "y", "content", "depth"],
        setup(props) {
          const { x, y, content } = Vue.toRefs(props);

          const room = roomContext.inject();
          const level = levelContext.inject();

          const contentContains = (type, f) =>
            containsContent(content.current, type, f);
          const isWall = Vue.computed(() => contentContains("wall"));
          const isBox = Vue.computed(() => contentContains("block"));
          const isPlayer = Vue.computed(() => contentContains("player"));
          const isButton = Vue.computed(() =>
            contentContains("floor", (x) => x.buttonType === "Button")
          );
          const isPlayerButton = Vue.computed(() =>
            contentContains("floor", (x) => x.buttonType === "PlayerButton")
          );
          const isRoom = Vue.computed(() => contentContains("room"));
          const innerRoom = Vue.computed(() => {
            if (props.depth === 0) return null;
            const roomId = isRoom.current
              ? content.current.find((x) => x.type === "room").id
              : null;
            return level.rooms.find((room) => room.id === roomId);
          });

          function wallAt(x, y) {
            return (
              !inBounds(room.current, x, y) ||
              containsContent(getContent(room.current, x, y), "wall")
            );
          }
          const hasRightWall = Vue.computed(
            () => isWall.current && wallAt(x.current + 1, y.current)
          );
          const hasLeftWall = Vue.computed(
            () => isWall.current && wallAt(x.current - 1, y.current)
          );
          const hasTopWall = Vue.computed(
            () => isWall.current && wallAt(x.current, y.current + 1)
          );
          const hasBottomWall = Vue.computed(
            () => isWall.current && wallAt(x.current, y.current - 1)
          );

          const wallClasses = Vue.computed(() => ({
            "cell--wall": isWall.current,
            "cell--wall--right": hasRightWall.current,
            "cell--wall--left": hasLeftWall.current,
            "cell--wall--top": hasTopWall.current,
            "cell--wall--bottom": hasBottomWall.current,
          }));

          return {
            isWall,
            isBox,
            isPlayer,
            isButton,
            isPlayerButton,
            isRoom,
            innerRoom,
            wallClasses,
          };
        },
      });
    </script>

    <style>
      .room-grid {
        display: grid;
        grid-auto-rows: 1fr;
        height: 100%;
        width: 100%;
      }
      .room-grid.room-grid--small {
        width: 100px;
        height: 100px;
      }
    </style>
    <script type="text/html" id="room-view">
      <svg class="cartesian" :viewBox="viewBox" :width="width" :height="height">
        <g>
          <!-- floor -->
          <template v-for="[x, y] of positions">
            <rect
              :x="x"
              :y="y"
              width="0.99"
              height="0.99"
              stroke="#333"
              :fill="roomFloorColor"
              stroke-width="0.01"
            ></rect>
          </template>
          <!-- walls -->
          <path
            :d="wallPath"
            :fill="roomWallColor"
            stroke-width="0.1"
            stroke="#666"
          ></path>
          <template
            v-for="{ x, y, box, button, eyes, roomId, text } of elements"
          >
            <g :transform="`translate(${x}, ${y})`">
              <rect
                v-if="box"
                x="0"
                y="0"
                width="1"
                height="1"
                :fill="box.color"
                stroke="black"
                :stroke-width="0.05"
              ></rect>
              <template v-if="roomId != null && depth > 0">
                <g transform="scale(1, -1) translate(0, -1)">
                  <room-view
                    :room-id="roomId"
                    :width="1"
                    :height="1"
                    :depth="depth - 1"
                  ></room-view>
                </g>
              </template>
              <rect
                v-if="button"
                x="0.1"
                y="0.1"
                width="0.8"
                height="0.8"
                stroke="#ddd"
                :stroke-width="0.05"
                fill="none"
              ></rect>
              <template v-if="eyes">
                <g
                  :fill="button ? '#ddd' : eyes === 'possess' ? 'none' : '#333'"
                  :stroke-width="eyes === 'possess' ? '0.02' : '0'"
                  stroke="#333"
                >
                  <circle cx="0.3" cy="0.6" r="0.1"></circle>
                  <circle cx="0.7" cy="0.6" r="0.1"></circle>
                </g>
              </template>
              <template v-if="text">
                <text
                  x="0.5"
                  y="0.5"
                  fill="black"
                  font-size="0.7"
                  text-anchor="middle"
                  alignment-baseline="middle"
                >
                  {{text}}
                </text>
              </template>
            </g>
          </template>
        </g>
      </svg>
    </script>
    <script>
      app.component("room-view", {
        template: "#room-view",
        props: {
          roomId: [String, Number],
          depth: {
            type: Number,
            default: 0,
          },
          size: String,
          width: {
            type: String,
            default: "100%",
          },
          height: {
            type: String,
            default: "100%",
          },
        },
        setup(props) {
          const level = levelContext.inject();
          const room = Vue.computed(() => {
            return level.rooms.find((x) => x.id === props.roomId);
          });

          roomContext.provide(room);

          const width = Vue.computed(() => room.current.width);
          const height = Vue.computed(() => room.current.height);

          const positions = Vue.computed(() =>
            pipe(range(width.current - 1, -1, -1), Array.from).flatMap((y) =>
              pipe(
                range(height.current),
                pipe.map((x) => [x, y]),
                Array.from
              )
            )
          );

          const gridStyles = Vue.computed(() => ({
            gridTemplateColumns: `repeat(${width.current}, 1fr)`,
          }));

          const classes = Vue.computed(() => ({
            "room-grid--small": props.size === "small",
          }));

          function getEyes(item) {
            return typeof item.player === "number"
              ? "player"
              : item.player === "possess"
              ? "possess"
              : null;
          }

          const elements = Vue.computed(() => {
            const result = [];
            room.current.contents.forEach((item) => {
              const { x, y } = item;
              if (item.type === "wall") {
                const eyes = getEyes(item);
                if (eyes) {
                  result.push({
                    x,
                    y,
                    eyes,
                  });
                }
              }
              if (item.type === "block") {
                result.push({
                  x,
                  y,
                  box: { color: tinycolor(item.color).toRgbString() },
                  eyes: getEyes(item),
                });
              }
              if (item.type === "floor" && item.buttonType === "PlayerButton") {
                result.push({ x, y, button: true, eyes: true });
              }
              if (item.type === "floor" && item.buttonType === "Button") {
                result.push({ x, y, button: true });
              }
              if (item.type === "room") {
                if (props.depth > 0) {
                  result.push({ x, y, roomId: item.id, eyes: getEyes(item) });
                } else {
                  result.push({
                    x,
                    y,
                    box: { color: "black" },
                    eyes: getEyes(item),
                  });
                }
                if (item.isClone ?? false) {
                  result.push({ x, y, box: { color: "#FFFA" } });
                }
                if (item.infEnterId != null) {
                  result.push({ x, y, text: "ε" });
                }
              }
              if (item.type === "inf-exit") {
                result.push({ x, y, text: "∞", roomId: item.refId });
              }
            });
            return result;
          });

          const getContent = (x, y) => {
            return room.current.contents.filter((i) => i.x === x && i.y === y);
          };

          const wallPath = Vue.computed(() => {
            const pointCycles = processWalls(room.current);
            let path = "";
            pointCycles.map((cycle) => {
              path += "M";
              cycle = insetShape(cycle, 0.05);
              cycle.forEach(({ x, y }) => {
                path += `${x},${y} `;
              });
              path += "z";
            });
            return path;
          });

          const roomFloorColor = Vue.computed(() => {
            return tinycolor(room.current.color).desaturate(50).toHexString();
          });

          const roomWallColor = Vue.computed(() => {
            return tinycolor(room.current.color).toHexString();
          });

          return {
            positions,
            gridStyles,
            classes,
            getContent,
            wallPath,
            elements,
            roomFloorColor,
            roomWallColor,
            viewBox: Vue.computed(
              () =>
                `0 ${-room.current.height} ${room.current.width} ${
                  room.current.height
                }`
            ),
          };
        },
      });
    </script>

    <style>
      .tool-group {
        display: inline-block;
        margin-right: 10px;
      }
      .tool-button {
        background: #ccc;
        border: 1px darkgray solid;
      }
      .tool-button:first-child {
        border-top-left-radius: 10px;
        border-bottom-left-radius: 10px;
      }
      .tool-button:last-child {
        border-top-right-radius: 10px;
        border-bottom-right-radius: 10px;
      }
      .tool-button--selected,
      .tool-button--active {
        background: white;
      }
    </style>
    <script type="text/html" id="tool-button">
      <button
        class="tool-button"
        :class="classes"
        @click="$emit('select-tool', tool.toolId)"
      >
        {{tool.name}}
      </button>
    </script>
    <script>
      app.component("tool-button", {
        template: "#tool-button",
        props: ["tool", "currentTool"],
        setup(props) {
          const isSelected = Vue.computed(
            () => props.tool.toolId === props.currentTool
          );
          const classes = Vue.computed(() => ({
            "tool-button--selected": isSelected.current,
          }));
          return {
            classes,
          };
        },
      });
    </script>

    <style>
      .properties-panel {
        border: 1px solid black;
        padding: 10px;
        margin: 10px 0;
      }
      .properties-panel__title {
        border-bottom: 2px solid gray;
        text-transform: uppercase;
        margin-bottom: 7px;
      }
    </style>
    <script type="text/html" id="properties-panel">
      <div class="properties-panel">
        <div class="properties-panel__title">{{title}}</div>
        <div class="properties.panel__content">
          <slot></slot>
        </div>
      </div>
    </script>
    <script>
      app.component("properties-panel", {
        template: "#properties-panel",
        props: ["title"],
      });
    </script>

    <script type="text/html" id="player-type-select-button">
      <button :class="classes" @click="$emit('select', value)">
        <slot></slot>
      </button>
    </script>
    <script>
      app.component("player-type-select-button", {
        template: "#player-type-select-button",
        props: ["value", "currentValue", "set"],
        setup(props) {
          const classes = Vue.computed(() => ({
            "tool-button": true,
            "tool-button--active": props.value === props.currentValue,
          }));
          return {
            classes,
          };
        },
      });
    </script>

    <script type="text/html" id="player-type-select">
      <div class="tool-group">
        <player-type-select-button
          class="tool-button"
          :value="null"
          :current-value="modelValue"
          @select="set($event)"
        >
          None
        </player-type-select-button>
        <player-type-select-button
          class="tool-button"
          :value="'possess'"
          :current-value="modelValue"
          @select="set($event)"
        >
          Possess
        </player-type-select-button>
        <player-type-select-button
          class="tool-button"
          :value="0"
          :current-value="modelValue"
          @select="set($event)"
        >
          1
        </player-type-select-button>
        <player-type-select-button
          class="tool-button"
          :value="1"
          :current-value="modelValue"
          @select="set($event)"
        >
          2
        </player-type-select-button>
        <player-type-select-button
          class="tool-button"
          :value="2"
          :current-value="modelValue"
          @select="set($event)"
        >
          3
        </player-type-select-button>
        <player-type-select-button
          class="tool-button"
          :value="3"
          :current-value="modelValue"
          @select="set($event)"
        >
          4
        </player-type-select-button>
        <player-type-select-button
          class="tool-button"
          :value="4"
          :current-value="modelValue"
          @select="set($event)"
        >
          5
        </player-type-select-button>
        <player-type-select-button
          class="tool-button"
          :value="5"
          :current-value="modelValue"
          @select="set($event)"
        >
          6
        </player-type-select-button>
        <player-type-select-button
          class="tool-button"
          :value="6"
          :current-value="modelValue"
          @select="set($event)"
        >
          7
        </player-type-select-button>
      </div>
    </script>
    <script>
      app.component("player-type-select", {
        template: "#player-type-select",
        props: ["modelValue"],
        setup(props, { emit }) {
          const set = (value) => {
            emit("update:modelValue", value);
          };
          return {
            set,
          };
        },
      });
    </script>

    <script type="text/html" id="tool-selector">
      <div>
        <div class="tool-group">
          <tool-button
            v-for="tool of TOOLS"
            :tool="tool"
            :current-tool="currentTool"
            @select-tool="$emit('select-tool', $event)"
          ></tool-button>
        </div>
        <div class="tool-group">
          <button class="tool-button" @click="changeRoom(-1)">Prev Room</button>
          <button class="tool-button" @click="changeRoom(+1)">Next Room</button>
        </div>
        <div class="tool-group">
          <button class="tool-button" @click="bigger">+</button>
          <button class="tool-button" @click="smaller">-</button>
        </div>
      </div>
    </script>
    <script>
      const makeTool = (toolId, name) => ({ toolId, name });
      const TOOLS = [
        makeTool("select", "Select"),
        makeTool("floor", "Floor"),
        makeTool("wall", "Wall"),
        makeTool("box", "Box"),
        makeTool("player", "Player"),
        makeTool("button", "Button"),
        makeTool("player-button", "Goal"),
        makeTool("room", "Room"),
        makeTool("clone", "Clone"),
        makeTool("inf-exit", "InfExit"),
      ];
      app.component("tool-selector", {
        template: "#tool-selector",
        props: ["currentTool"],
        setup() {
          const level = levelContext.inject();
          const state = stateContext.inject();
          const room = roomContext.inject();
          const changeRoom = (delta) => {
            const roomIndex = level.rooms.findIndex((r) => r === room.current);
            const newRoomIndex =
              (roomIndex + level.rooms.length + delta) % level.rooms.length;
            state.room = level.rooms[newRoomIndex].id;
          };
          const bigger = () => {
            expandRoom(room.current, 1, 1, 1, 1);
          };
          const smaller = () => {
            expandRoom(room.current, -1, -1, -1, -1);
          };
          return {
            TOOLS,
            changeRoom,
            bigger,
            smaller,
          };
        },
      });
    </script>

    <style>
      .room-select__grid {
        display: flex;
        gap: 10px;
        flex: row wrap;
        justify-content: start;
      }
      .room-select__grid-cell {
        border-radius: 5px;
        padding: 10px;
      }
      .room-select__grid-cell:hover {
        background: #bbb;
      }
    </style>
    <script type="text/html" id="room-select">
      <div class="app-modal__card">
        <div class="room-select__grid">
          <template v-for="room of level.rooms">
            <div
              class="room-select__grid-cell"
              @click="$emit('select', room.id)"
            >
              <room-view size="small" :room-id="room.id" :depth="0"></room-view>
            </div>
          </template>
        </div>
        <div class="tool-group">
          <button class="tool-button" @click="$emit('select', null)">
            New
          </button>
        </div>
      </div>
    </script>
    <script>
      app.component("room-select", {
        template: "#room-select",
        setup() {
          const level = levelContext.inject();

          return {
            level,
          };
        },
      });
    </script>

    <style>
      .cell-select-overlay {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: grid;
        grid-auto-rows: 1fr;
        z-index: 1;
      }
    </style>
    <script type="text/html" id="cell-select-overlay">
      <div class="cell-select-overlay" :style="gridStyles">
        <div
          v-for="[x, y] of positions"
          @click="$emit('click-cell', [x, y])"
        ></div>
      </div>
    </script>
    <script>
      app.component("cell-select-overlay", {
        template: "#cell-select-overlay",
        props: {
          width: Number,
          height: Number,
        },
        setup(props) {
          const positions = Vue.computed(() =>
            pipe(range(props.width - 1, -1, -1), Array.from).flatMap((y) =>
              pipe(
                range(props.height),
                pipe.map((x) => [x, y]),
                Array.from
              )
            )
          );

          const gridStyles = Vue.computed(() => ({
            gridTemplateColumns: `repeat(${props.width}, 1fr)`,
          }));

          return {
            positions,
            gridStyles,
          };
        },
      });
    </script>

    <script type="text/html" id="room-editor">
      <tool-selector
        :current-tool="currentTool"
        @select-tool="currentTool = $event"
      />
      <div style="width: 520px; height: 520px; position: relative;">
        <room-view :room-id="roomId" :depth="1" />
        <cell-select-overlay
          :width="room.width"
          :height="room.height"
          @click-cell="onCellClicked"
        ></cell-select-overlay>
      </div>
      <properties-panel title="ROOM">
        <div>Color: <color-input v-model="room.color" /></div>
        <div>
          Void Plane: <input type="checkbox" v-model="room.isVoidPlane" />
        </div>
        <div>Zoom Factor: <input v-model="room.zoomFactor" type="range" min="0.1" max="1.0" step="0.01" /></div>
      </properties-panel>
      <properties-panel v-if="selected" :title="selected.title">
        <template v-if="selected.hasColor">
          <div>Color: <color-input v-model="selected.item.color" /></div>
        </template>
        <template v-if="selected.canBePlayer">
          <div>
            Player: <player-type-select v-model="selected.item.player" />
          </div>
        </template>
        <template v-if="selected.canFlip">
          <div>
            Flip: <input type="checkbox" v-model="selected.item.flipped" />
          </div>
        </template>
        <template v-if="selected.canBeInfEnter">
          <div>
            Infinite Enter:
            <div class="tool-group">
              <button
                class="tool-button"
                @click="selectInfEnterRoom(selected.item)"
              >
              Select
              </button>
              <button
              v-if="selected.item.infEnterId != null"
              class="tool-button"
              @click="selected.item.infEnterId = null"
              >
              Clear
            </button>
            </div>
          </div>
        </template>
        <template v-if="selected.hasInfiniteOrder">
          <div>
            Order:
            <div class="tool-group">
              <button
              class="tool-button"
              @click="selected.item.order = Math.max(selected.item.order - 1, 0)"
              >
              -
            </button>
            <span class="tool-button">{{selected.item.order + 1}}</span>
            <button class="tool-button" @click="selected.item.order++">
              +
            </button>
          </div>
        </div>
        </template>
      </properties-panel>
      <properties-panel title="level">
        <div>Extrude: <input type="checkbox" v-model="level.extrude"/></div>
        <div>Inner Push: <input type="checkbox" v-model="level.innerPush" /></div>
        <div>Style: <select v-model="level.style">
          <option value="normal">Normal</option>
          <option value="tui">TUI</option>
          <option value="grid">Grid</option>
          <option value="oldstyle">Gallery</option>
        </select></div>
      </properties-panel>
    </script>
    <script>
      app.component("room-editor", {
        template: "#room-editor",
        props: ["roomId"],
        setup(props, { emit }) {
          const currentTool = Vue.ref("floor");
          const state = stateContext.inject();
          const level = levelContext.inject();
          const room = Vue.computed(() =>
            level.rooms.find((r) => r.id === props.roomId)
          );
          const onCellClicked = ([x, y]) => {
            function removeAt() {
              room.current.contents = room.current.contents.filter((c) => {
                if (c.x === x && c.y === y) {
                  return false;
                }
                return true;
              });
            }
            if (currentTool.current === "select") {
              if (
                selectedCell.current &&
                selectedCell.current.x === x &&
                selectedCell.current.y === y
              ) {
                selectedCell.current = null;
              } else {
                selectedCell.current = [x, y];
              }
            }
            if (currentTool.current === "floor") {
              removeAt();
            }
            if (currentTool.current === "wall") {
              removeAt();
              room.current.contents.push({ type: "wall", x, y });
            }
            if (currentTool.current === "box") {
              removeAt();
              room.current.contents.push({
                type: "block",
                x,
                y,
                color: { h: 40, s: 1, v: 1 },
              });
            }
            if (currentTool.current === "player") {
              removeAt();
              removeInLevel(level, (c) => c.type === "block" && c.player === 0);
              room.current.contents.push({
                type: "block",
                x,
                y,
                player: 0,
                color: { h: 0, s: 1, v: 1 },
              });
            }
            if (currentTool.current === "button") {
              removeAt();
              room.current.contents.push({
                type: "floor",
                x,
                y,
                buttonType: "Button",
              });
            }
            if (currentTool.current === "player-button") {
              removeAt();
              room.current.contents.push({
                type: "floor",
                x,
                y,
                buttonType: "PlayerButton",
              });
            }
            if (currentTool.current === "room") {
              removeAt();
              state.roomSelect = {
                type: "room",
                x,
                y,
                targetId: state.room,
              };
            }
            if (currentTool.current === "clone") {
              removeAt();
              state.roomSelect = {
                type: "clone",
                x,
                y,
                targetId: state.room,
              };
            }
            if (currentTool.current === "inf-exit") {
              removeAt();
              state.roomSelect = {
                type: "inf-exit",
                x,
                y,
                targetId: state.room,
              };
            }
          };

          const selectedCell = Vue.ref(null);

          const selected = Vue.computed(() => {
            if (selectedCell.current == null) {
              return null;
            }

            for (const x of getContent(
              room.current,
              selectedCell.current[0],
              selectedCell.current[1]
            )) {
              if (x.type === "room") {
                return {
                  title: "room ref",
                  item: x,
                  hasColor: false,
                  canBePlayer: true,
                  canFlip: true,
                  canBeInfEnter: true,
                  hasInfiniteOrder: x.infEnterId != null,
                };
              }
              if (x.type === "block") {
                return {
                  title: "block",
                  item: x,
                  hasColor: true,
                  canBePlayer: true,
                  canFlip: false,
                  canBeInfEnter: false,
                };
              }
              if (x.type === "wall") {
                return {
                  title: "wall",
                  item: x,
                  hasColor: false,
                  canBePlayer: true,
                  canFlip: false,
                  canBeInfEnter: false,
                };
              }
              if (x.type === "inf-exit") {
                return {
                  title: "infinite exit",
                  item: x,
                  hasColor: false,
                  canBePlayer: true,
                  canFlip: true,
                  hasInfiniteOrder: true,
                };
              }
            }
          });

          const selectInfEnterRoom = (target) => {
            state.roomSelect = {
              type: "inf-enter",
              target,
            };
          };

          roomContext.provide(room);

          return {
            room,
            level,
            currentTool,
            onCellClicked,
            selected,
            selectInfEnterRoom,
          };
        },
      });
    </script>

    <style>
      .app-modal__card {
        border-radius: 5px;
        background: white;
        padding: 20px;
      }
      .app-modal__container {
        z-index: 1000;
        position: fixed;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
      }
      .app-modal__scrim {
        position: absolute;
        z-index: 1001;
        top: 0;
        bottom: 0;
        left: 0;
        right: 0;
        background: #eeea;
      }
      .app-modal__content {
        position: relative;
        z-index: 1002;
        margin-top: 100px;
        margin-left: auto;
        margin-right: auto;
        width: 520px;
      }
    </style>
    <script type="text/html" id="app-modal">
      <teleport to="body">
        <div class="app-modal__container">
          <div class="app-modal__scrim" @click="$emit('close')"></div>
          <div class="app-modal__content">
            <slot></slot>
          </div>
        </div>
      </teleport>
    </script>
    <script>
      app.component("app-modal", {
        template: "#app-modal",
      });
    </script>

    <style>
      .level-code {
        font-family: "Courier New", Courier, monospace;
        white-space: pre;
      }
    </style>
    <script type="text/html" id="main-app">
      <div class="container">
        <div class="full-column mt mb position-root">
          <room-editor
            v-if="state.room !== null"
            :room-id="state.room"
          ></room-editor>
          <button @click="showLevel = !showLevel">Toggle Level!</button>
          <button @click="saveLevel">Save!</button>
          <div v-if="showLevel" class="level-code">{{levelAsText}}</div>
          <app-modal v-if="state.roomSelect" @close="state.roomSelect = null">
            <room-select @select="handleRoomSelect"></room-select>
          </app-modal>
        </div>
      </div>
    </script>
    <script>
      function defaultRoom(id) {
        return {
          id,
          width: 5,
          height: 5,
          color: { h: 216, s: 0.8, v: 1.0 },
          isVoidPlane: false,
          zoomFactor: 1.0,
          contents: [],
        };
      }
      app.component("main-app", {
        template: "#main-app",
        setup() {
          const level = Vue.reactive({
            title: "An Interesting Level",
            extrude: false,
            innerPush: false,
            style: "normal",
            rooms: [defaultRoom(0)],
          });

          const state = Vue.reactive({
            gallery: true,
            room: 0,
            roomSelect: null,
            nextRoomId: 1,
          });
          const levelAsText = Vue.computed(() => levelToFile(level));
          const showLevel = Vue.ref(true);

          const handleRoomSelect = (selectedRoomId) => {
            if (state.roomSelect != null) {
              const { type, x, y, targetId: targetRoomId } = state.roomSelect;
              if (selectedRoomId === null) {
                const newRoom = defaultRoom(state.nextRoomId++);
                level.rooms.push(newRoom);
                selectedRoomId = newRoom.id;
              }
              const targetRoom = level.rooms.find((r) => r.id === targetRoomId);
              if (type === "inf-exit") {
                targetRoom.contents.push({
                  type: "inf-exit",
                  x,
                  y,
                  // TODO automatic order
                  order: 0,
                  refId: selectedRoomId,
                });
              } else if (type === "inf-enter") {
                state.roomSelect.target.infEnterId = selectedRoomId;
                state.roomSelect.target.order = 0;
              } else {
                // TODO if not clone, remove any other instances of this room
                targetRoom.contents.push({
                  type: "room",
                  x,
                  y,
                  id: selectedRoomId,
                  isClone: type === "clone",
                });
              }
              state.roomSelect = null;
            }
          };

          const saveLevel = () => {
            fetch("/save", {
              method: "POST",
              body: JSON.stringify({
                fileName: `${level.title.replace(/\W+/g, "-")}.txt`,
                text: levelAsText.current,
              }),
              headers: {
                "Content-type": "application/json; charset=UTF-8",
              },
            });
          };

          levelContext.provide(level);
          stateContext.provide(state);

          return {
            level,
            state,
            showLevel,
            levelAsText,
            handleRoomSelect,
            saveLevel,
          };
        },
      });

      function removeInLevel(level, pred) {
        level.rooms.forEach((room) => {
          spliceIf(room.contents, (x) => pred(x));
        });
      }
      function spliceIf(array, pred) {
        let i = 0;
        while (i < array.length) {
          if (pred(array[i], i, array)) {
            array.splice(i, 1);
          } else {
            i++;
          }
        }
      }
      function getContent(room, x, y) {
        const contents = room.contents.filter((c) => c.x === x && c.y === y);
        return contents;
      }
      function inBounds(room, x, y) {
        return 0 <= x && x < room.width && 0 <= y && y < room.height;
      }
      function containsContent(contents, type, f) {
        return (
          contents.filter((c) => c.type === type && (f == null || f(c)))
            .length > 0
        );
      }
      function expandRoom(
        room,
        expandTop,
        expandRight,
        expandBottom,
        expandLeft
      ) {
        const newWidth = room.width + expandLeft + expandRight;
        const newHeight = room.height + expandTop + expandBottom;

        const newContents = [];

        for (const x of range(0, newWidth)) {
          for (const y of range(0, newHeight)) {
            let oldX = x - expandLeft;
            let oldY = y - expandBottom;
            let outside =
              oldX < 0 || oldX >= room.width || oldY < 0 || oldY >= room.height;
            oldX = clamp(oldX, 0, room.width - 1);
            oldY = clamp(oldY, 0, room.height - 1);
            const contents = getContent(room, oldX, oldY);
            newContents.push(
              ...contents
                .filter((c) => {
                  // only walls should be expanded
                  return !outside || c.type === "wall";
                })
                .map((c) => ({ ...c, x, y }))
            );
          }
        }

        room.width = newWidth;
        room.height = newHeight;
        room.contents = newContents;
      }

      function clamp(x, lo, hi) {
        return x < lo ? lo : x > hi ? hi : x;
      }

      class Writer {
        constructor() {
          this.output = "";
          this.lineEnding = "\n";
          this.indentWith = "\t";

          this.indents = [];
          this.lineStart = true;
        }

        write(x) {
          this.ensureIndent();
          this.lineStart = false;
          this.output += x;
        }
        writeLine(x) {
          this.write(x);
          this.endLine();
        }
        getIndent() {
          return this.indents.join("");
        }
        ensureIndent() {
          if (this.lineStart) {
            this.output += this.getIndent();
            this.lineStart = false;
          }
        }
        endLine() {
          this.output += this.lineEnding;
          this.lineStart = true;
        }
        indented(...args) {
          let indentWith, cb;
          if (args.length >= 2) {
            indentWith = args[0];
            cb = args[1];
          }
          if (args.length <= 1) {
            cb = args[0];
          }
          this.indents.push(indentWith ?? this.indentWith);
          cb();
          this.indents.pop();
        }
      }
      function pointEqual(a, b) {
        return a.x === b.x && a.y === b.y;
      }
      class KeyedMap extends Map {
        constructor(keyComputer, ...args) {
          super(...args);
          this.keyComputer = keyComputer;
        }
        getByValue(value) {
          const key = this.keyComputer.call(undefined, value);
          if (this.has(key)) {
            return this.get(key);
          }
          return undefined;
        }
        setByValue(value) {
          const key = this.keyComputer.call(undefined, value);
          this.set(key, value);
        }
        deleteByValue(value) {
          const key = this.keyComputer.call(undefined, value);
          this.delete(key);
        }
      }
      // function insetShape (points, delta) {
      //   function get(i) {
      //     return points[(i + points.length) % points.length]
      //   }
      //   const length = a => Math.sqrt(a.x * a.x + a.y * a.y)
      //   const normalize = a => {
      //     const aLength = length(a)
      //     return { x: a.x / aLength, y: a.y / aLength }
      //   }
      //   const diff = (a, b) => ({ x: a.x - b.x, y: a.y - b.y })
      //   const mul = (a, k) => ({ x: a.x * k, y: a.y * k })
      //   const add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y })
      //   return points.map((curr, i) => {
      //     const prev = get(i - 1)
      //     const next = get(i + 1)

      //     const a = normalize(diff(curr, prev))
      //     const b = normalize(diff(next, curr))

      //     const c = mul(diff(b, a), delta)
      //     return add(curr, c)
      //   })
      // }
      function insetShape(points, delta) {
        function get(i) {
          return points[(i + points.length) % points.length];
        }
        const length = (a) => Math.sqrt(a.x * a.x + a.y * a.y);
        const normalize = (a) => {
          const aLength = length(a);
          return { x: a.x / aLength, y: a.y / aLength };
        };
        const diff = (a, b) => ({ x: a.x - b.x, y: a.y - b.y });
        const mul = (a, k) => ({ x: a.x * k, y: a.y * k });
        const add = (a, b) => ({ x: a.x + b.x, y: a.y + b.y });
        const angle = (a) => Math.atan2(a.y, a.x);
        const polar = (r, theta) => ({
          x: r * Math.cos(theta),
          y: r * Math.sin(theta),
        });
        return points.map((curr, i) => {
          const prev = get(i - 1);
          const next = get(i + 1);

          const a = normalize(diff(prev, curr));
          const b = normalize(diff(next, curr));

          const aAngle = angle(a);
          const bAngle = angle(b);
          const spanAngle = (aAngle - bAngle) / 2;
          const cAngle = (aAngle + bAngle) / 2;
          // sin(spanAngle) = delta / h
          const h = delta / Math.sin(spanAngle);

          return add(curr, polar(h, cAngle));
        });
      }
      function processWalls(room) {
        function getNodeKey(node) {
          const { x: x1, y: y1 } = node;
          const { x: x2, y: y2 } = node.next;
          if (x1 === x2) {
            return `x${x1}-${Math.min(y1, y2)}-${Math.max(y1, y2)}`;
          } else {
            return `y${y1}-${Math.min(x1, x2)}-${Math.max(x1, x2)}`;
          }
        }
        const walls = room.contents.filter((x) => x.type === "wall");
        const resultEdgeSets = [];
        const allNodes = new Set();
        const nodeMap = new KeyedMap(getNodeKey);
        walls.forEach((wall) => {
          const { x, y } = wall;
          const p1 = { x, y, next: null };
          const p2 = { x: x + 1, y, next: null };
          const p3 = { x: x + 1, y: y + 1, next: null };
          const p4 = { x, y: y + 1, next: null };
          p1.next = p2;
          p2.next = p3;
          p3.next = p4;
          p4.next = p1;
          allNodes.add(p1);
          allNodes.add(p2);
          allNodes.add(p3);
          allNodes.add(p4);

          for (const p of [p1, p2, p3, p4]) {
            let t;
            if ((t = nodeMap.getByValue(p))) {
              nodeMap.deleteByValue(t);
              [p.next, t.next] = [t.next, p.next];
            } else {
              nodeMap.setByValue(p);
            }
          }
        });

        const pointCycles = [];
        while (allNodes.size > 0) {
          const p = allNodes.values().next().value;
          const cycle = [p];
          let pp = p;
          allNodes.delete(p);
          while (pp.next !== p) {
            pp = pp.next;
            allNodes.delete(pp);
            cycle.push(pp);
          }
          const cycleNoDups = cycle.filter((x, i) => {
            return !pointEqual(x, cycle[(i + 1) % cycle.length]);
          });
          if (cycleNoDups.length > 0) {
            pointCycles.push(cycleNoDups);
          }
        }
        return pointCycles;
      }
      function levelToFile(level) {
        function b(value) {
          return value ? "1" : "0";
        }
        function color(value) {
          return `${value.h / 360} ${value.s} ${value.v}`;
        }
        function player(value) {
          return `${b(typeof value === "number")} ${b(value != null)} ${
            typeof value === "number" ? value : "0"
          }`;
        }
        const file = new Writer();
        file.writeLine("version 4");
        if (level.extrude) {
          file.writeLine("shed 1");
        }
        if (level.innerPush) {
          file.writeLine("inner_push 1");
        }
        if (level.style !== "normal") {
          file.writeLine("draw_style " + level.style)
        }
        file.writeLine("#");
        function infEnter(room) {
          return room.infEnterId != null
            ? `1 ${room.order} ${roomToId.get(idToRoom.get(room.infEnterId))}`
            : `0 0 0`;
        }
        const idToRoom = new Map();
        const roomToId = new Map();
        let currentRoomId = 1;
        level.rooms.forEach((x) => {
          idToRoom.set(x.id, x);
          roomToId.set(x, currentRoomId++);
        });
        playerRoomId = currentRoomId++;

        level.rooms.forEach((room, index) => {
          const roomId = roomToId.get(room);
          file.writeLine(
            `Block -1 -1 ${roomId} ${room.width} ${room.height} ${color(
              room.color
            )} ${room.zoomFactor} 0 0 0 0 0 1 0`
          );
          file.indented(() => {
            // 
            if (room.isVoidPlane) {
              file.writeLine(`Ref -1 -1 ${roomId} 1 0 0 0 0 0 0 0 0 0 1 0`)
            }
            room.contents.forEach((x) => {
              if (x.type === "wall") {
                file.writeLine(`Wall ${x.x} ${x.y} ${player(x.player)}`);
              }
              if (x.type === "floor") {
                file.writeLine(`Floor ${x.x} ${x.y} ${x.buttonType}`);
              }
              if (x.type === "block") {
                file.writeLine(
                  `Block ${x.x} ${x.y} ${currentRoomId++} 1 1 ${color(
                    x.color
                  )} 1 1 ${player(x.player)} ${b(x.flipped)} 0 0`
                );
              }
              if (x.type === "room") {
                const targetRoomId = roomToId.get(idToRoom.get(x.id));
                file.writeLine(
                  `Ref ${x.x} ${x.y} ${targetRoomId} ${b(
                    !(x.isClone ?? false)
                  )} 0 0 ${infEnter(x)} 0 ${player(x.player)} ${b(
                    x.flipped
                  )} 0 0`
                );
              }
              if (x.type === "inf-exit") {
                const targetRoomId = roomToId.get(idToRoom.get(x.refId));
                file.writeLine(
                  `Ref ${x.x} ${x.y} ${targetRoomId} 0 1 ${
                    x.order
                  } 0 0 0 ${player(x.player)} ${b(x.flipped)} 0 0`
                );
              }
            });
          });
        });
        return file.output;
      }
    </script>

    <div id="app">
      <main-app></main-app>
    </div>
    <script>
      app.use(ColorInput);
      window.root = app.mount("#app");
    </script>
  </body>
</html>
